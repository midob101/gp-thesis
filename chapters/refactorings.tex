\section{Refactorings}

\subsection{Yoda conditions}

Yoda conditions are conditions in the form \verb|a compop b|, where \verb|a| is a constant and \verb|b| is a expression.
Non Yoda conditions are conditions in the form \verb|b compop a|, where \verb|a| is a constant and \verb|b| is a expression.

Usually in software development, you want to follow one style and use it for the whole project. Therefore, various IDEs and other tools like lexers exist, which check
the styling and if possible fix them automatically. These tools may not exist for domain specific languages, therefore a usecase of this project can be those refactorings.

To implement this refactoring, we are using the extended MiniJava syntax. At first, we are applying a selector to find all comparison operators in the AST.
From the result, we can simply grab the left and right side of the node, as they are decorated with an alias. If the left side is an integer literal, we swap the left and right node.
At the end, we need to swap the \verb|compop| to the reflect the changes. \verb|<| will become \verb|>=|, \verb|>| will become \verb|<=|, \verb|<=| will become \verb|>|, \verb|>=| will become \verb|<|.
\verb|==| will not need to be adjusted.

With this simple code, we can adjust an entire project to not use yoda expressions. As we chose to add the whitespaces as real nodes to the AST, even though they are hidden, we do not mess up with the whitespaces.
The node that corresponds to \verb|a| does only contain the \verb|a| constant. Any whitespaces between \verb|a| and \verb|compop| will be a seperate node in the AST. Therefore, by swapping a and b the formatting
of the file stays the same.

\subsection{Unreachable code removal}

There are many cases of unreachable code, we will focus on just one case. Code that appears after a return statement in the same block, is code that will never be executed.
With this refactoring, we want to remove all code, which is happening after a return statement.

This is done by creating a selector to grab all \verb|return| statements. Once we done that, we receive the parent node of the \verb|return|. Now we loop over the children, and after we found the \verb|return| node, we begin to remove following nodes.

\subsection{Code transpilation}

This project may also be used to transpile code from a source grammar to a target grammar. As an example, a transpiler was written, which transpiles applications that use
the extended MiniJava grammar to applications that use the regular MiniJava grammar. An example of a transpiler which performs operations like these would be babel. This tool is
used to transpile a newer version of JavaScript into an older one, which can be executed by more browser. That allows the developer to utilize new functionalities of the programming language while not breaking backwards compability.

The goal of this implementation is to show the power of a rewritable abstract syntax tree. Especially for extended return syntax, we have to apply severe modifications to the sources
to make it MiniJava compatible.

\subsection{Limitations}

As only an abstract syntax tree is generated, there is no way to easily find out which variable declaration gets used at which places, or 

\subsection{Automated Refactoring}

Hier Beispiel/Beispiele f端r automatisierte Refactorings anf端hren. Beispielsweise Funktionsnamen von underscore zu camelCase 端berf端hren.