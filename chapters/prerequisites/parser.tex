
\subsection{Parser}

The parsing process is done by applying the grammar rules on the token stream. 
There are many types of parsers, two common ones used in compiler development are:

\begin{enumerate}
\item LL(1): Scanning the input from left to right, applying leftmost deriviation, using one token of lookahead.
\item LR(1): Scanning the input from left to right, applying rightmost deriviation, using one token of lookahead.
\end{enumerate}

There are two goals of the parsing process. 
The first is to verify that the input conforms to the grammar. 
The second is to generate a tree structure that represents the input. 
The tree structure generated by the parser is called a Concrete Syntax Tree (CST). 
This tree structure is very verbose and represents the grammar definition exactly.

There are two main ways to parse source code. 
LL(1) parsing is an example of top-down parsing.
In top-down parsing, the root node is created first, followed by the child nodes, and the leaf nodes are created at the end.  
LR(1) is an example of a bottom-up parsing algorithm.
In this parsing strategy, the leaf nodes are generated first, and the root node is generated at the very end. 


LL(1) has the advantage of being relatively easy to understand, but is less powerful than LR(1). 
LR(1) parsers are harder to understand and debug, but can parse more grammars then LL(1).

Each of the presented parsers are not able to parse all context free grammars, but they are sufficient enough to parse most programming languages. 
LR(1) is a parsing strategy that is able to parse many grammars, but requires a large amount of memory and computation to parse correctly.

Since memory and runtime are not the main priority in this thesis, a LR(1) parser was implemented to allow a large number of grammars to be parsed.

The LR(1) parser was first described by \cite{KNUTH1965607}.

The LR(1) parsing strategy relies on two different tables. The construction of the tables is explained in \cite[pages 259-266]{AhoLSU2006}.

The following example is taken from \cite[pages 263, 265, 266]{AhoLSU2006}.

Let $N = \{S, C\}, \Sigma = \{c, d\}, S = S$ be a grammar with the productions $P$ defined as

\begin{align}
P = \{&S \rightarrow C\text{ }C\\
&C \rightarrow c\text{ }C\\
&C \rightarrow d\}
\end{align}

Let r1 be a reference to the production rule $S \rightarrow C\text{ }C$, r2 be a reference to $C \rightarrow c\text{ }C$ and r3 be a reference to $C \rightarrow d$.

The first table is called the action table.

\begin{table}[H]
\centering
\begin{tabular}{c|ccc}
State & $c$ & $d$ & \$\\
\hline 
0 & s3 & s4 & \\
1 &    &    & acc \\
2 & s6 & s7 & \\
3 & s3 & s4 & \\
4 & r3 & r3 & \\
5 & & & r1\\
6 & s6 & s7 & \\
7 & & & r3\\
8 & r2 & r2 & \\
9 & & & r2
\end{tabular} 
\caption{LR(1) action table}
\end{table}

The rows represent different states. 
The columns represent the terminal symbols of the grammar. 
The value of each cell can be empty, a shift, a reduce or an accept action.  
The \verb|$| symbol is a special symbol that refers to the end of input.

A shift action will consume a token from the token stream and move to a new state. 
For example, s6 will perform a shift and move to state 6.

A reduce action returns to a previously encountered state and references a grammar rule that is being reduced.

An accept action is defined only once in the entire table. Once it is encountered, the parsing process is complete and the input has been successfully parsed.

The second table is the goto table. 

\begin{table}
\centering
\begin{tabular}{c|cc}
State & $S$ & $C$\\
\hline 
0 & 1 & 2\\
1 &    &     \\
2 &  & 5 \\
3 &  & 8  \\
4 &  &   \\
5 &  & \\
6 &  & 9 \\
7 &  & \\
8 &  &  \\
9 &  & 
\end{tabular} 
\caption{LR(1) goto table}
\end{table}

The columns represent the non-terminal symbols of the grammar. 
The content of each cell can be either a reference to another state or empty.

The parser itself maintains a stack of states. 
The top of the stack is the current state being processed. 
The parser reads the current token from the token stream provided by the lexer and gets the current action from the action table.
Depending on the action type, different behaviors apply.

On a shift action the parser will shift the position in the token stream and continue in the next iteration with a new token. 
The new state defined in the shift action is pushed to the stack. Then the next iteration is started.

On a reduce action, the parser will pop $n$ states from the stack, where $n$ is equal to the number of terminal and nonterminal 
symbols to the right of the grammar rule. Then the new top of stack is read and the state defined in the goto 
table for the left hand symbol of the reduced grammar rule is pushed onto the stack.

On an accept action, the parser will complete the parsing process by accepting the input. 

For example, the parsing process of the word \verb|cdcd| will be performed the steps shown in table \ref{table:lr1_parse_example}.

\begin{table}
\centering
\begin{tabular}{c|l|c|c|c|c}
Iteration & State stack & Action & Goto & Token stream & Description\\
\hline 
1 & 0 & s3 & & \verb|cdcd| & Perform a shift to s3.\\
\hline 
2 & 0 3 & s4 & & \verb|dcd| & Perform a shift to s4.\\
\hline 
\multirow{2}{*}{3} & 0 3 4 & r3 &  & \verb|cd| & Reduce $C \rightarrow d$\\
& 0 3 & & 8 & \verb|cd| & Go to state 8\\
\hline 
\multirow{2}{*}{4} & 0 3 8 & r2 & & \verb|cd| & Reduce $C \rightarrow c C$\\
& 0 &  & 2 & \verb|cd| & Go to state 2\\
\hline 
5 & 0 2 & s6 & & \verb|cd| & Perform a shift to s6.\\
\hline 
6 & 0 2 6 & s7 & & \verb|d| & Perform a shift to s7.\\
\hline 
\multirow{2}{*}{7} & 0 2 6 7 & r3 & & \verb|$| & Reduce $C \rightarrow d$\\
& 0 2 6 &  & 9 & \verb|$| & Go to state 9\\
\hline 
\multirow{2}{*}{8} & 0 2 6 9 & r2 & & \verb|$| & Reduce $C \rightarrow c C$\\
& 0 2 &  & 5 & \verb|$| & Go to state 5\\
\hline 
\multirow{2}{*}{9} & 0 2 5 & r1 & & \verb|$| & Reduce $S \rightarrow C C$\\
& 0 &  & 1 & \verb|$| & Go to state 1\\
\hline 
10 & 0 1 & acc & & \verb|$| & Accept the input.\\
\end{tabular}
\caption{LR(1) parse example}
\label{table:lr1_parse_example}
\end{table}

The algorithms for the LL(1) and LR(1) parser is described in further detail in \cite[pages 45-67]{Appel2002-kleene} and in \cite[chapter 4 - Syntax analysis]{AhoLSU2006}.

The LR(1) parsing algorithm is implemented manually, as customizations to this parsing process will be required to attach nodes to the abstract syntax tree
which are not part of the grammar specification. These customizations are described in a later chapter.

The implementation is based on the algorithms described in \cite[Handouts 10, 11]{stanford_course}.